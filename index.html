<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小番茄图片混淆批量处理工具</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(90deg, #180161, #4f1787, #eb3678);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
        }
        
        .description {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: rgba(255, 255, 255, 0.95);
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .main-content {
            padding: 35px;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .upload-section {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            border: 3px dashed #4f1787;
            text-align: center;
            transition: all 0.3s;
        }
        
        .upload-section:hover {
            border-color: #eb3678;
            background: #f0f7ff;
        }
        
        .file-input {
            display: none;
        }
        
        .upload-btn {
            background: #4f1787;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s;
            display: inline-block;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(79, 23, 135, 0.4);
        }
        
        .upload-btn:hover {
            background: #3c1269;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(79, 23, 135, 0.6);
        }
        
        .process-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .process-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            min-width: 200px;
        }
        
        .encrypt-btn {
            background: #4f1787;
            color: white;
        }
        
        .encrypt-btn:hover {
            background: #3c1269;
            transform: translateY(-3px);
        }
        
        .decrypt-btn {
            background: #eb3678;
            color: white;
        }
        
        .decrypt-btn:hover {
            background: #d42a67;
            transform: translateY(-3px);
        }
        
        .download-btn {
            background: #fb773c;
            color: white;
        }
        
        .download-btn:hover {
            background: #e5672b;
            transform: translateY(-3px);
        }
        
        .process-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .progress-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .progress-title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #180161;
            text-align: center;
            font-size: 1.2rem;
        }
        
        .progress-bar {
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4f1787, #eb3678);
            border-radius: 15px;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .progress-text {
            text-align: center;
            font-weight: bold;
            color: #180161;
        }
        
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .image-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }
        
        .image-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }
        
        .image-preview {
            width: 100%;
            height: 150px;
            object-fit: contain;
            border-radius: 8px;
            margin-bottom: 10px;
            background: #ddd;
        }
        
        .image-name {
            font-weight: bold;
            color: #180161;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 5px;
        }
        
        .image-status {
            font-size: 0.9rem;
            color: #666;
        }
        
        .info-box {
            background: #e3f2fd;
            padding: 25px;
            border-radius: 12px;
            border-left: 5px solid #4f1787;
        }
        
        .info-title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #180161;
            font-size: 1.3rem;
            text-align: center;
        }
        
        .info-list {
            list-style-type: none;
            padding: 15px 0;
        }
        
        .info-list li {
            padding: 12px 0;
            border-bottom: 1px dashed #ccc;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .info-list li:last-child {
            border-bottom: none;
        }
        
        .info-list li::before {
            content: '✓';
            color: #4f1787;
            font-weight: bold;
            font-size: 1.2rem;
        }
        
        footer {
            text-align: center;
            padding: 25px;
            background: #180161;
            color: white;
        }
        
        .settings-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .settings-title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #180161;
            text-align: center;
        }
        
        .settings-group {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        
        .setting-item {
            flex: 1;
            min-width: 200px;
        }
        
        .setting-label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #180161;
        }
        
        .setting-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        @media (max-width: 768px) {
            .process-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .process-btn {
                width: 100%;
                max-width: 300px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .main-content {
                padding: 25px;
            }
            
            .settings-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>小番茄图片混淆批量处理工具</h1>
            <p class="description">基于空间填充曲线的新一代图片混淆 - 批量处理版</p>
        </header>
        
        <div class="main-content">
            <div class="upload-section">
                <h2>上传多张图片进行批量处理</h2>
                <p>支持JPG, PNG, BMP, WEBP等常见图片格式</p>
                <label for="fileInput" class="upload-btn">
                    📁 选择多张图片
                </label>
                <input type="file" id="fileInput" class="file-input" accept="image/*" multiple>
                <p id="selectedFiles">未选择文件</p>
            </div>
            
            <div class="process-buttons">
                <button id="encryptBtn" class="process-btn encrypt-btn" disabled>批量混淆图片</button>
                <button id="decryptBtn" class="process-btn decrypt-btn" disabled>批量解混淆图片</button>
                <button id="downloadBtn" class="process-btn download-btn" disabled>下载所有图片</button>
            </div>
            
            <div class="progress-container">
                <div class="progress-title">处理进度</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">0 / 0 已完成</div>
            </div>
            
            <div class="image-grid" id="imageGrid">
                <!-- 图片预览将在这里动态生成 -->
            </div>
            
            <div class="info-box">
                <div class="info-title">工具功能说明</div>
                <ul class="info-list">
                    <li>基于希尔伯特曲线空间填充算法进行像素位置变换</li>
                    <li>保持像素的空间相关性，压缩后仍能保持色彩</li>
                    <li>批量处理多张图片，支持同时混淆或解混淆</li>
                    <li>处理后的图片格式为JPEG，质量0.95</li>
                    <li>可视化处理进度和实时预览</li>
                    <li>一键下载所有处理后的图片</li>
                </ul>
                <p>使用说明：上传图片后选择"批量混淆图片"或"批量解混淆图片"，处理完成后可以查看每张图片的效果，最后点击"下载所有图片"保存结果。</p>
            </div>
        </div>
        
        <footer>
            <p>© 2023 小番茄图片混淆批量处理工具 | 基于希尔伯特曲线算法</p>
        </footer>
    </div>

    <script>
        // 原代码中的希尔伯特曲线生成函数
        function gilbert2d(width, height) {
            /**
             * Generalized Hilbert ('gilbert') space-filling curve for arbitrary-sized
             * 2D rectangular grids. Generates discrete 2D coordinates to fill a rectangle
             * of size (width x height).
             */
            const coordinates = [];

            if (width >= height) {
                generate2d(0, 0, width, 0, 0, height, coordinates);
            } else {
                generate2d(0, 0, 0, height, width, 0, coordinates);
            }

            return coordinates;
        }

        function generate2d(x, y, ax, ay, bx, by, coordinates) {
            const w = Math.abs(ax + ay);
            const h = Math.abs(bx + by);

            const dax = Math.sign(ax), day = Math.sign(ay); // unit major direction
            const dbx = Math.sign(bx), dby = Math.sign(by); // unit orthogonal direction

            if (h === 1) {
                // trivial row fill
                for (let i = 0; i < w; i++) {
                    coordinates.push([x, y]);
                    x += dax;
                    y += day;
                }
                return;
            }

            if (w === 1) {
                // trivial column fill
                for (let i = 0; i < h; i++) {
                    coordinates.push([x, y]);
                    x += dbx;
                    y += dby;
                }
                return;
            }

            let ax2 = Math.floor(ax / 2), ay2 = Math.floor(ay / 2);
            let bx2 = Math.floor(bx / 2), by2 = Math.floor(by / 2);

            const w2 = Math.abs(ax2 + ay2);
            const h2 = Math.abs(bx2 + by2);

            if (2 * w > 3 * h) {
                if ((w2 % 2) && (w > 2)) {
                    // prefer even steps
                    ax2 += dax;
                    ay2 += day;
                }

                // long case: split in two parts only
                generate2d(x, y, ax2, ay2, bx, by, coordinates);
                generate2d(x + ax2, y + ay2, ax - ax2, ay - ay2, bx, by, coordinates);

            } else {
                if ((h2 % 2) && (h > 2)) {
                    // prefer even steps
                    bx2 += dbx;
                    by2 += dby;
                }

                // standard case: one step up, one long horizontal, one step down
                generate2d(x, y, bx2, by2, ax2, ay2, coordinates);
                generate2d(x + bx2, y + by2, ax, ay, bx - bx2, by - by2, coordinates);
                generate2d(x + (ax - dax) + (bx2 - dbx), y + (ay - day) + (by2 - dby),
                    -bx2, -by2, -(ax - ax2), -(ay - ay2), coordinates);
            }
        }

        // 原代码中的加密函数
        function encrypt(img) {
            return new Promise((resolve) => {
                const cvs = document.createElement("canvas");
                const width = cvs.width = img.width;
                const height = cvs.height = img.height;
                const ctx = cvs.getContext("2d");
                ctx.drawImage(img, 0, 0);
                const imgdata = ctx.getImageData(0, 0, width, height);
                const imgdata2 = new ImageData(width, height);
                const curve = gilbert2d(width, height);
                const offset = Math.round((Math.sqrt(5) - 1) / 2 * width * height);
                for(let i = 0; i < width * height; i++){
                    const old_pos = curve[i];
                    const new_pos = curve[(i + offset) % (width * height)];
                    const old_p = 4 * (old_pos[0] + old_pos[1] * width);
                    const new_p = 4 * (new_pos[0] + new_pos[1] * width);
                    imgdata2.data.set(imgdata.data.slice(old_p, old_p + 4), new_p);
                }
                ctx.putImageData(imgdata2, 0, 0);
                cvs.toBlob(b => {
                    resolve(URL.createObjectURL(b));
                }, "image/jpeg", 0.95);
            });
        }

        // 原代码中的解密函数
        function decrypt(img) {
            return new Promise((resolve) => {
                const cvs = document.createElement("canvas");
                const width = cvs.width = img.width;
                const height = cvs.height = img.height;
                const ctx = cvs.getContext("2d");
                ctx.drawImage(img, 0, 0);
                const imgdata = ctx.getImageData(0, 0, width, height);
                const imgdata2 = new ImageData(width, height);
                const curve = gilbert2d(width, height);
                const offset = Math.round((Math.sqrt(5) - 1) / 2 * width * height);
                for(let i = 0; i < width * height; i++){
                    const old_pos = curve[i];
                    const new_pos = curve[(i + offset) % (width * height)];
                    const old_p = 4 * (old_pos[0] + old_pos[1] * width);
                    const new_p = 4 * (new_pos[0] + new_pos[1] * width);
                    imgdata2.data.set(imgdata.data.slice(new_p, new_p + 4), old_p);
                }
                ctx.putImageData(imgdata2, 0, 0);
                cvs.toBlob(b => {
                    resolve(URL.createObjectURL(b));
                }, "image/jpeg", 0.95);
            });
        }

        // DOM元素引用
        const fileInput = document.getElementById('fileInput');
        const encryptBtn = document.getElementById('encryptBtn');
        const decryptBtn = document.getElementById('decryptBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const selectedFiles = document.getElementById('selectedFiles');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const imageGrid = document.getElementById('imageGrid');
        
        // 存储上传的图片和处理结果
        let uploadedImages = [];
        let processedImages = [];
        let currentlyProcessing = 0;
        const maxConcurrent = 3; // 最大同时处理数
        
        // 文件选择事件
        fileInput.addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                selectedFiles.textContent = `已选择 ${e.target.files.length} 个文件`;
                encryptBtn.disabled = false;
                decryptBtn.disabled = false;
                
                // 清空之前的图片
                uploadedImages = [];
                processedImages = [];
                imageGrid.innerHTML = '';
                
                // 处理每个文件
                Array.from(e.target.files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            uploadedImages.push({
                                index: index,
                                name: file.name,
                                originalUrl: URL.createObjectURL(file),
                                image: img,
                                width: img.width,
                                height: img.height,
                                status: 'waiting'
                            });
                            
                            // 添加到预览网格
                            const imageItem = document.createElement('div');
                            imageItem.className = 'image-item';
                            imageItem.innerHTML = `
                                <img class="image-preview" src="${URL.createObjectURL(file)}" alt="${file.name}">
                                <div class="image-name">${file.name}</div>
                                <div class="image-status" data-index="${index}">等待处理</div>
                            `;
                            imageGrid.appendChild(imageItem);
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            }
        });
        
        // 批量处理函数
        async function batchProcess(mode) {
            if (uploadedImages.length === 0) return;
            
            encryptBtn.disabled = true;
            decryptBtn.disabled = true;
            downloadBtn.disabled = true;
            
            processedImages = [];
            const total = uploadedImages.length;
            let completed = 0;
            
            // 更新进度条
            progressFill.style.width = '0%';
            progressText.textContent = `0 / ${total} 已完成`;
            
            // 处理函数
            const processNextImage = async () => {
                if (completed >= total) return;
                
                // 找到下一个等待处理的图片
                const nextIndex = uploadedImages.findIndex(img => img.status === 'waiting');
                if (nextIndex === -1) return;
                
                // 标记为处理中
                uploadedImages[nextIndex].status = 'processing';
                const statusElement = document.querySelector(`.image-status[data-index="${nextIndex}"]`);
                statusElement.textContent = '处理中...';
                statusElement.style.color = '#4f1787';
                
                currentlyProcessing++;
                
                try {
                    const imageData = uploadedImages[nextIndex];
                    const processFunc = mode === 'encrypt' ? encrypt : decrypt;
                    const processedUrl = await processFunc(imageData.image);
                    
                    processedImages.push({
                        index: nextIndex,
                        name: imageData.name,
                        originalUrl: imageData.originalUrl,
                        processedUrl: processedUrl
                    });
                    
                    // 更新预览
                    document.querySelector(`.image-item:nth-child(${nextIndex + 1}) .image-preview`).src = processedUrl;
                    statusElement.textContent = mode === 'encrypt' ? '已混淆' : '已解混淆';
                    statusElement.style.color = '#2ecc71';
                    uploadedImages[nextIndex].status = 'completed';
                    
                } catch (error) {
                    statusElement.textContent = '处理失败';
                    statusElement.style.color = '#e74c3c';
                    console.error(`处理图片 ${uploadedImages[nextIndex].name} 时出错:`, error);
                    uploadedImages[nextIndex].status = 'failed';
                }
                
                completed++;
                currentlyProcessing--;
                
                const progress = Math.round((completed / total) * 100);
                progressFill.style.width = `${progress}%`;
                progressText.textContent = `${completed} / ${total} 已完成`;
                
                // 处理下一张图片
                if (currentlyProcessing < maxConcurrent) {
                    processNextImage();
                }
                
                // 如果所有图片都处理完成，启用下载按钮
                if (completed === total) {
                    downloadBtn.disabled = false;
                }
            };
            
            // 启动初始处理任务
            for (let i = 0; i < Math.min(maxConcurrent, total); i++) {
                processNextImage();
            }
        }
        
        // 按钮事件
        encryptBtn.addEventListener('click', () => batchProcess('encrypt'));
        decryptBtn.addEventListener('click', () => batchProcess('decrypt'));
        
        // 下载所有图片
        downloadBtn.addEventListener('click', async function() {
            if (processedImages.length === 0) return;
            
            for (let i = 0; i < processedImages.length; i++) {
                const imageData = processedImages[i];
                
                try {
                    // 获取Blob数据
                    const response = await fetch(imageData.processedUrl);
                    const blob = await response.blob();
                    
                    // 创建下载链接
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `${imageData.name.replace(/\.[^/.]+$/, "")}_processed.jpg`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    // 更新状态
                    const statusElement = document.querySelector(`.image-status[data-index="${imageData.index}"]`);
                    statusElement.textContent = '已下载';
                    statusElement.style.color = '#3498db';
                    
                } catch (error) {
                    console.error(`下载图片 ${imageData.name} 时出错:`, error);
                    const statusElement = document.querySelector(`.image-status[data-index="${imageData.index}"]`);
                    statusElement.textContent = '下载失败';
                    statusElement.style.color = '#e74c3c';
                }
                
                // 添加一点延迟，避免同时发起太多下载请求
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        });
    </script>
</body>
</html>
